# 安全指南

> 本文从传输安全、业务安全、配置安全和插件安全几个维度，  
> 总结 CarryPigeon Backend 的安全设计与实践建议。

---

## 1. 传输与协议安全

### 1.1 加密与握手

- 使用 ECC + AES-GCM 组合：
  - 握手阶段由客户端本地生成 AES 会话密钥，并使用服务器 ECC 公钥加密后发送给服务器；
  - 业务阶段使用 AES-GCM 对 JSON 业务数据进行加密。

握手流程简要：

1. 服务端启动时加载或生成 ECC 密钥对，公钥通过安全途径分发给客户端；
2. 客户端本地生成 AES 会话密钥，对其 Base64 文本使用服务器公钥加密后封装为 `CPAESKeyPack { id, sessionId, key }` 发送给服务器；
3. 服务器使用 ECC 私钥解密得到 AES 密钥，保存到会话状态，并发送一条 `route="handshake"` 的加密通知，双方进入加密通信阶段。

### 1.2 AAD 与重放防护

- 业务包中携带 AAD（`AeadAad`）：
  - 包序号（int）；
  - sessionId（long）；
  - 时间戳（long 毫秒）。
- 服务端检查：
  - 包序号必须单调递增：
    - 防止重放攻击；
    - 检测乱序包；
  - sessionId 必须与当前会话一致：
    - 防止跨会话混淆；
  - 时间戳必须在允许窗口内（例如 ±3 分钟）：
    - 防止长时间重放。

建议：

- 客户端与服务端使用统一的时间源（NTP 同步），避免因时间漂移导致误判；
- 对于时间窗口内的少量偏差，通过日志记录并观察，而不是直接放宽安全限制。

---

## 2. 业务安全与权限控制

### 2.1 登录状态与会话

- 登录态通过 `CPUserToken` 与 `CPSession` 管理；
- `UserLoginCheckerNode` 负责：
  - 从 `CPSession` 属性中读取当前用户 id；
  - 在 LiteFlow 上下文中写入 `SessionId`；
  - 未登录时返回 `CPResponse.code=300`（权限错误）。

建议：

- 所有需要认证的业务链路最前面都应包含 `UserLoginChecker`；
- 对于允许匿名访问的链路，应谨慎设计其能力范围。

### 2.2 资源权限（频道/成员/消息）

通过一系列 `checker` 节点实现：

- 频道相关：
  - 所有者校验（OwnerChecker）：确保只有频道 owner 才能修改或删除频道；
  - 管理员校验（AdminChecker）：确保仅管理员执行特定操作（踢人、禁言等）。

- 成员相关：
  - 成员存在性校验：只有频道成员才能发送消息、更新读状态、拉取未读数等；

- 禁言相关：
  - 在发送消息链路中加入禁言检查节点，禁止被禁言用户发送消息。

建议：

- 在新增链路时复用现有 checker 节点，保持权限逻辑一致；
- 对于高风险操作（如删除消息、删除成员）优先以管理员/所有者权限为前置条件。

### 2.3 参数校验

- 所有节点应在 `process` 开始阶段调用：
  - `requireContext` / `requireBind`；
  - 或手动检查上下文数据是否存在。
- 参数错误时应调用 `argsError(context)`：
  - 统一返回 `CPResponse.ERROR_RESPONSE`（code=100）；
  - 通过日志记录节点 id 和错误信息。

---

## 3. 配置与敏感信息

### 3.1 配置管理

- 将敏感配置（数据库密码、Redis 密码、MinIO 密钥、SMTP 凭证等）从：
  - `application.yaml` 中剥离；
  - 改为通过环境变量、配置中心或密钥管理系统注入。

### 3.2 日志中的敏感信息

- 避免在日志中输出：
  - 完整 token；
  - 密码、密钥；
  - 明文隐私数据（邮箱可以按需脱敏）。
- 对于必要的调试输出可采用：
  - 只输出 token 的前几位；
  - 或在测试环境调高日志级别，而在生产环境保持最小必要信息。

---

## 4. 插件安全

### 4.1 侵入性插件

侵入性插件通过替换 DAO 或外部服务实现参与核心逻辑，需要特别注意：

- 接口契约：
  - 行为与默认实现一致（错误码、异常类型、边界条件处理）；
  - 不应在接口实现中引入额外副作用。

- 访问控制：
  - 避免插件实现访问不必要的资源（文件系统、其他内部服务）；
  - 若必须访问，需通过安全组、防火墙等机制限制范围。

- 部署策略：
  - 必须先在测试/预发布环境充分验证；
  - 使用配置开关（`@ConditionalOnProperty`）控制启用/禁用；
  - 预留回滚方案。

### 4.2 拓展性插件

拓展性插件以 LiteFlow 节点形式存在，安全风险相对较低，但仍需：

- 不在节点中执行：
  - 任意文件 IO；
  - 任意系统命令；
  - 长时间阻塞调用。

- 将“安全敏感操作”封装在宿主提供的 Service 中：
  - 插件节点只调用这些 Service，而不是直接访问底层资源。

详细的插件安全建议见：  
`doc/plugins/plugin-security-and-sandbox.md`。

---

## 5. 防护与监控

### 5.1 防止恶意请求

- 帧长限制：
  - `NettyDecoder` 限制单帧最大长度（例如 64KB），防止大包攻击；
- 协议一致性校验：
  - 解密失败、JSON 解析失败、AAD 校验失败时及时关闭连接；
- 心跳与空闲检测：
  - 使用 `CPNettyHeartBeatHandler` 检测长时间无活动的连接并关闭。

### 5.2 安全监控

- 日志监控：
  - 定期分析 `error.log` / `error-json.log` 中与 AAD、解密、权限相关的错误；
- 指标监控：
  - 对登录失败、权限拒绝、参数错误等指标进行统计，识别异常模式。

---

## 6. 安全开发建议

在开发新功能或插件时，可以使用以下检查清单：

1. 是否正确使用了登录和权限 checker 节点？
2. 参数校验是否完备，是否所有必填字段都在进入节点前检查？
3. 是否避免在日志中输出敏感信息？
4. 是否考虑了 AAD 时间窗口和重放攻击防护？
5. 插件是否只通过公共接口访问宿主，而不触碰内部实现类？
6. 是否在测试/预发布环境验证过安全相关行为（权限、异常路径、边界条件）？

结合本指南和其他 ops 文档，可以在扩展功能的同时尽量减少安全风险。 
